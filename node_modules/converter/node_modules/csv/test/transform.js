// Generated by CoffeeScript 1.8.0

/*
Test CSV - Copyright David Worms <open@adaltas.com> (BSD Licensed)
 */

(function() {
  var csv, fs, nextTick, should, timers;

  fs = require('fs');

  should = require('should');

  csv = process.env.CSV_COV ? require('../lib-cov') : require('../src');

  timers = require('timers');

  nextTick = timers.setImmediate ? timers.setImmediate : process.nextTick;

  describe('transform', function() {
    describe('sync', function() {
      it('should be able to reorder fields', function(next) {
        var count;
        count = 0;
        return csv().from.string("20322051544,1979.0,8.8017226E7,ABC,45,2000-01-01\n28392898392,1974.0,8.8392926E7,DEF,23,2050-11-27").transform(function(record, index) {
          count.should.eql(index);
          count++;
          record.unshift(record.pop());
          return record;
        }).on('end', function() {
          return count.should.eql(2);
        }).to.string(function(result) {
          result.should.eql("2000-01-01,20322051544,1979.0,8.8017226E7,ABC,45\n2050-11-27,28392898392,1974.0,8.8392926E7,DEF,23");
          return next();
        });
      });
      it('should skip all lines where transform return undefined', function(next) {
        var count;
        count = 0;
        return csv().from.string("20322051544,1979.0,8.8017226E7,ABC,45,2000-01-01\n28392898392,1974.0,8.8392926E7,DEF,23,2050-11-27").transform(function(record, index) {
          count.should.eql(index);
          count++;
          return null;
        }).on('close', function() {
          return count.should.eql(2);
        }).to.string(function(result) {
          result.should.eql('');
          return next();
        });
      });
      it('should skip all lines where transform return null', function(next) {
        var count;
        count = 0;
        return csv().from.string("20322051544,1979.0,8.8017226E7,ABC,45,2000-01-01\n28392898392,1974.0,8.8392926E7,DEF,23,2050-11-27\n82378392929,1972.0,8.8392926E7,FJI,23,2012-04-30\n47191084482,1978.0,8.8392926E7,2FF,23,2064-02-15\n28718040423,1973.0,8.8392926E7,FRE,23,1970-09-02\n24792823783,1971.0,8.8392926E7,POF,23,1978-06-09").transform(function(record, index) {
          count.should.eql(index);
          count++;
          if (index % 2) {
            return record;
          } else {
            return null;
          }
        }).on('close', function() {
          return count.should.eql(6);
        }).to.string(function(result) {
          result.should.eql("28392898392,1974.0,8.8392926E7,DEF,23,2050-11-27\n47191084482,1978.0,8.8392926E7,2FF,23,2064-02-15\n24792823783,1971.0,8.8392926E7,POF,23,1978-06-09");
          return next();
        });
      });
      it('should recieve an array and return an object', function(next) {
        return csv().from.string("20322051544,1979,8.8017226E7,ABC,45,2000-01-01\n28392898392,1974,8.8392926E7,DEF,23,2050-11-27").transform(function(record, index) {
          return {
            field_1: record[4],
            field_2: record[3]
          };
        }).on('close', function(count) {
          return count.should.eql(2);
        }).on('error', function(e) {
          return should.be.ok(false);
        }).to.string(function(result) {
          result.should.eql("45,ABC\n23,DEF");
          return next();
        });
      });
      it('should accept a returned string', function(next) {
        return csv().from.string("20322051544,1979,8.8017226E7,ABC,45,2000-01-01\n28392898392,1974,8.8392926E7,DEF,23,2050-11-27").transform(function(record, index) {
          return (index > 0 ? ',' : '') + record[4] + ":" + record[3];
        }).on('close', function(count) {
          return count.should.eql(2);
        }).to.string(function(result) {
          result.should.eql('45:ABC,23:DEF');
          return next();
        });
      });
      it('should accept a returned number', function(next) {
        return csv().from.string('a\nb\nc').transform(function(record, index) {
          return index + 1;
        }).on('close', function(count) {
          return count.should.eql(2);
        }).to.string(function(data) {
          data.should.eql('123');
          return next();
        });
      });
      it('should accept a returned integer', function(next) {
        var i, result, test, _i;
        result = '';
        test = csv().transform(function(record, index) {
          return record[1];
        }).on('data', function(record) {
          return result += record;
        }).on('end', function() {
          result.should.eql('210');
          return next();
        });
        for (i = _i = 2; _i >= 0; i = --_i) {
          test.write(['Test ' + i, i, '"']);
        }
        return test.end();
      });
      it('should accept a returned array with different types', function(next) {
        return csv().from.string("20322051544,8.8017226E7,4.5,1978-10-09,,1\n28392898392,8.8392926E7,8.3,2000-01-01,1,").transform(function(record, index) {
          record[3] = record[3].split('-');
          return [parseInt(record[0]), parseFloat(record[1]), parseFloat(record[2]), Date.UTC(record[3][0], record[3][1], record[3][2]), !!record[4], !!record[5]];
        }).on('end', function(count) {
          return count.should.eql(2);
        }).to.string(function(result) {
          result.should.eql("20322051544,88017226,4.5,279417600000,,1\n28392898392,88392926,8.3,949363200000,1,");
          return next();
        });
      });
      it('should catch error thrown in transform callback', function(next) {
        var count, error, i, test, _i, _results;
        count = 0;
        error = false;
        test = csv().transform(function(record, index) {
          if (index % 10 === 9) {
            throw new Error("Error at index " + index);
          }
          return record;
        }).on('error', function(e) {
          error = true;
          e.message.should.equal('Error at index 9');
          return setTimeout(next, 100);
        }).on('record', function(record) {
          return record[1].should.be.below(9);
        }).on('end', function() {
          return false.should.be.ok;
        }).to.string(function(result) {
          return false.should.be.ok;
        });
        _results = [];
        for (i = _i = 0; _i < 1000; i = ++_i) {
          if (!error) {
            _results.push(test.write(['Test ' + i, i, '"']));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      it('shoud handle columns option with header', function(next) {
        return csv().from('col1,col2\na1,a2\nb1,b2', {
          columns: true
        }).to(function(data) {
          data.should.eql("col1,col2,foo\na1,a2,bar\nb1,b2,bar");
          return next();
        }, {
          newColumns: true,
          header: true
        }).transform(function(data, index) {
          data.foo = 'bar';
          return data;
        });
      });
      return it('should transform a large file', function(next) {
        var expectedFirstLine;
        expectedFirstLine = 'id,name,date';
        return csv().from.path("" + __dirname + "/transform.csv", {
          columns: true
        }).to.string(function(res) {
          var firstLine;
          firstLine = res.slice(0, expectedFirstLine.length);
          firstLine.should.eql(expectedFirstLine);
          return next();
        }).to.options({
          header: true
        }).transform(function(row, i) {
          return row;
        });
      });
    });
    return describe('async', function() {
      it('should output the record if passed in the callback as an array', function(next) {
        return csv().from('a1,b1\na2,b2').to(function(data) {
          data.should.eql('b1,a1\nb2,a2');
          return next();
        }).transform(function(record, index, callback) {
          return nextTick(function() {
            return callback(null, record.reverse());
          });
        });
      });
      it('should output the record if passed in the callback as an object', function(next) {
        return csv().from('a1,b1\na2,b2').to(function(data) {
          data.should.eql('b1,a1\nb2,a2');
          return next();
        }).transform(function(record, index, callback) {
          return nextTick(function() {
            return callback(null, {
              a: record[1],
              b: record[0]
            });
          });
        });
      });
      it('should skip the record if callback called without a record', function(next) {
        return csv().from('a1,b1\na2,b2\na3,b3\na4,b4').to(function(data) {
          data.should.eql('a1,b1\na3,b3');
          return next();
        }).transform(function(record, index, callback) {
          return nextTick(function() {
            return callback(null, index % 2 === 0 ? record : null);
          });
        });
      });
      it('should run 20 transforms in parallel by default', function(next) {
        var count, i, test, _i;
        count = 0;
        test = csv().to(function(data) {
          return next();
        }).transform(function(record, index, callback) {
          count++;
          return nextTick(function() {
            (count <= 20).should.be.ok;
            count--;
            return callback(null, record);
          });
        }, {
          parallel: 20
        });
        for (i = _i = 0; _i < 100; i = ++_i) {
          test.write('Goldorak go\n');
        }
        return test.end();
      });
      it('should run sequentially if parallel is 1', function(next) {
        var count, i, running, test, _i;
        running = 0;
        count = 0;
        test = csv().to(function(data) {
          return next();
        }).transform(function(record, index, callback) {
          index.should.eql(count);
          count++;
          running.should.equal(0);
          running++;
          return nextTick(function() {
            running--;
            running.should.equal(0);
            return callback(null, record);
          });
        }, {
          parallel: 1
        });
        for (i = _i = 0; _i < 100; i = ++_i) {
          test.write('Goldorak go\n');
        }
        return test.end();
      });
      it('shoud handle columns option with header', function(next) {
        return csv().from('col1,col2\na1,a2\nb1,b2', {
          columns: true
        }).to(function(data) {
          data.should.eql("col1,col2,foo\na1,a2,bar\nb1,b2,bar");
          return next();
        }, {
          newColumns: true,
          header: true
        }).transform(function(data, index, callback) {
          return nextTick(function() {
            data.foo = 'bar';
            return callback(null, data);
          });
        });
      });
      it('should transform a large file', function(next) {
        var expectedFirstLine;
        expectedFirstLine = 'id,name,date';
        return csv().from.path("" + __dirname + "/transform.csv", {
          columns: true
        }).to.string(function(res) {
          var firstLine;
          firstLine = res.slice(0, expectedFirstLine.length);
          firstLine.should.eql(expectedFirstLine);
          return next();
        }).to.options({
          header: true
        }).transform(function(row, i, cb) {
          return setTimeout((function() {
            return cb(null, row);
          }), 10);
        });
      });
      return it.skip('should accept more records while still transforming', function(next) {
        var test;
        test = csv().from.array([
          {
            a: '1',
            b: '2'
          }, {
            a: '3',
            b: '4'
          }
        ]).to(function(data) {
          data.should.eql("a_col,b_col\n5,6\n1,2\n3,4");
          return next();
        }, {
          columns: ['a_col', 'b_col'],
          header: true
        }).transform(function(data, index, callback) {
          return nextTick(function() {
            var arr, row;
            arr = Array.isArray(data);
            row = {
              a_col: arr ? data[0] : data.a,
              b_col: arr ? data[1] : data.b
            };
            return callback(null, row);
          });
        });
        return test.write(['5', '6']);
      });
    });
  });

}).call(this);

//# sourceMappingURL=transform.js.map
